#!/usr/bin/env node

// Toolbox Tool - Tree-sitter Diff Entity Extractor

const action = process.env.TOOLBOX_ACTION || '';

switch (action) {
  case 'describe':
    console.log(`name: extract_diff_entities
description: Extract methods and classes from git diff using tree-sitter AST parsing
diff_content: string The unified git diff content to analyze`);
    break;

  case 'execute':
    let input = '';
    
    process.stdin.setEncoding('utf8');
    process.stdin.on('data', (chunk) => {
      input += chunk;
    });
    
    process.stdin.on('end', async () => {
      try {
        // Extract diff_content parameter
        const diffMatch = input.match(/^diff_content:\s*(.*)$/ms);
        const diffContent = diffMatch ? diffMatch[1] : '';
        
        if (!diffContent) {
          console.error('Error: diff_content parameter required');
          process.exit(1);
        }
        
        // Use tree-sitter extraction - no fallback
        const entities = await extractEntitiesWithTreeSitter(diffContent);
        
        // Output as JSON for Amp to consume
        console.log(JSON.stringify({
          entities_found: entities.length,
          extraction_method: 'tree-sitter-typescript',
          note: 'Using official tree-sitter-typescript from https://github.com/tree-sitter/tree-sitter-typescript',
          entities: entities.map(entity => ({
            id: entity.id,
            file: entity.file, 
            line: entity.line || entity.start,
            start: entity.start,
            end: entity.end,
            kind: entity.kind,
            name: entity.name
          }))
        }, null, 2));
        
      } catch (error) {
        console.error(`Error extracting entities: ${error.message}`);
        process.exit(1);
      }
    });
    break;

  default:
    console.error("Error: TOOLBOX_ACTION must be 'describe' or 'execute'");
    process.exit(1);
}

async function extractEntitiesWithTreeSitter(diffContent) {
  // Official tree-sitter-typescript implementation
  const Parser = require('tree-sitter');
  const TypeScript = require('tree-sitter-typescript').typescript;
  const JavaScript = require('tree-sitter-javascript');
  const fs = require('fs');
  const path = require('path');

  const entities = [];
  let entityId = 1;

  // Parse the unified diff
  const hunks = parseUnifiedDiff(diffContent);

  // Set up parsers for different languages
  const tsParser = new Parser();
  tsParser.setLanguage(TypeScript);
  
  const jsParser = new Parser();
  jsParser.setLanguage(JavaScript);

  const getParser = (fileName) => {
    const ext = path.extname(fileName);
    if (['.ts', '.tsx'].includes(ext)) return tsParser;
    if (['.js', '.jsx'].includes(ext)) return jsParser;
    if (['.vue', '.mjs'].includes(ext)) return jsParser; // Vue SFC and modules use JS parser
    return null;
  };

  for (const hunk of hunks) {
    const parser = getParser(hunk.file);
    if (!parser) {
      console.error(`No tree-sitter parser available for ${hunk.file}`);
      continue;
    }

    // Try to read the file content
    let sourceCode;
    try {
      sourceCode = fs.readFileSync(hunk.file, 'utf8');
    } catch (error) {
      console.error(`Could not read file ${hunk.file}:`, error.message);
      continue;
    }

    try {
      const tree = parser.parse(sourceCode);
      const fileEntities = extractEntitiesFromTreeSitterAST(tree, hunk.file, hunk.addedLines, sourceCode, entityId);
      entities.push(...fileEntities);
      entityId += fileEntities.length;
    } catch (error) {
      console.error(`Error parsing ${hunk.file} with tree-sitter:`, error.message);
    }
  }

  return entities;
}





function shouldSkipFile(file) {
  return file.includes('.tools/') ||
         file.includes('__tests__/') ||
         file.includes('.github/') ||
         /(?:^|\/).*\.tools\./.test(file) ||
         /\.(test|spec)\.[jt]sx?$/.test(file) ||
         /\.(yml|yaml|md|txt|json)$/.test(file);
}

function parseUnifiedDiff(diffContent) {
  const hunks = [];
  const lines = diffContent.split('\n');
  
  let currentFile = null;
  let newLineNum = 0;
  let addedLines = new Set();

  for (const line of lines) {
    // File header: diff --git a/file b/file
    const fileMatch = line.match(/^diff --git a\/(.+) b\/(.+)$/);
    if (fileMatch) {
      // Save previous file's data
      if (currentFile && addedLines.size > 0) {
        hunks.push({ file: currentFile, newStart: newLineNum, addedLines: new Set(addedLines) });
      }
      
      currentFile = fileMatch[2]; // Use the 'b/' (new) file path
      
      // Skip tool files and test files
      if (shouldSkipFile(currentFile)) {
        currentFile = null;
        addedLines = new Set();
        continue;
      }
      
      addedLines = new Set();
      continue;
    }

    // Skip index, mode, and file status lines
    if (line.startsWith('index ') || line.startsWith('new file') || 
        line.startsWith('deleted file') || line.startsWith('--- ') || 
        line.startsWith('+++ ')) {
      continue;
    }

    // Hunk header: @@ -old,count +new,count @@
    const hunkMatch = line.match(/^@@ -\d+,?\d* \+(\d+),?\d* @@/);
    if (hunkMatch) {
      newLineNum = parseInt(hunkMatch[1]);
      continue;
    }

    // Process diff lines
    if (currentFile && (line.startsWith('+') || line.startsWith('-') || line.startsWith(' '))) {
      if (line.startsWith('+') && !line.startsWith('+++')) {
        addedLines.add(newLineNum);
        newLineNum++;
      } else if (line.startsWith('-') && !line.startsWith('---')) {
        // Don't increment newLineNum for deleted lines
      } else if (line.startsWith(' ')) {
        newLineNum++;
      }
    }
  }

  // Don't forget the last file
  if (currentFile && addedLines.size > 0) {
    hunks.push({ file: currentFile, newStart: newLineNum, addedLines });
  }

  return hunks;
}

function extractEntitiesFromTreeSitterAST(tree, filePath, addedLines, sourceCode, startId) {
  const entities = [];
  const rootNode = tree.rootNode;
  let entityId = startId;

  const traverse = (node) => {
    // Check if this node represents a function, method, class, etc.
    const nodeTypes = [
      'function_declaration', 'method_definition', 'arrow_function',
      'class_declaration', 'interface_declaration', 'type_alias_declaration',
      'function_definition', 'class_definition', // Python
      'function_declaration', 'method_declaration', 'type_declaration', // Go
      'method_declaration', 'class_declaration', 'interface_declaration', // Java
      'function_item', 'impl_item', 'struct_item', 'enum_item', // Rust
      'function_definition', 'struct_specifier', 'enum_specifier' // C/C++
    ];

    if (nodeTypes.includes(node.type)) {
      const startLine = node.startPosition.row + 1; // Convert to 1-based
      const endLine = node.endPosition.row + 1;

      // Check if any added lines intersect with this node
      const hasIntersection = Array.from(addedLines).some(
        line => line >= startLine && line <= endLine
      );

      if (hasIntersection) {
        const nameNode = findNameNode(node);
        const name = nameNode ? sourceCode.slice(nameNode.startIndex, nameNode.endIndex) : 'anonymous';
        
        const entity = {
          id: `${filePath}:${startLine}-${endLine}:${entityId++}`,
          file: filePath,
          line: startLine,
          start: startLine,
          end: endLine,
          kind: mapNodeTypeToKind(node.type),
          name,
          content: sourceCode.slice(node.startIndex, node.endIndex)
        };
        
        entities.push(entity);
      }
    }

    // Recursively traverse children
    for (let i = 0; i < node.childCount; i++) {
      traverse(node.child(i));
    }
  };

  traverse(rootNode);
  return entities;
}

function findNameNode(node) {
  // Common name node types across languages
  const nameTypes = ['identifier', 'name', 'type_identifier'];
  
  for (let i = 0; i < node.childCount; i++) {
    const child = node.child(i);
    if (child && nameTypes.includes(child.type)) {
      return child;
    }
  }
  return null;
}

function mapNodeTypeToKind(nodeType) {
  if (nodeType.includes('function')) return 'function';
  if (nodeType.includes('method')) return 'method';
  if (nodeType.includes('class')) return 'class';
  if (nodeType.includes('interface')) return 'interface';
  if (nodeType.includes('struct')) return 'struct';
  if (nodeType.includes('enum')) return 'enum';
  if (nodeType.includes('type')) return 'type';
  return 'unknown';
}
