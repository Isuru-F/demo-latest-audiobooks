name: AMP Review Bot

on:
  pull_request:
    types: [opened, synchronize]

permissions:
  contents: read
  pull-requests: write

jobs:
  amp-review:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Fetch PR data
        id: pr
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.AMP_REVIEW_GH_TOKEN }}
          script: |
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number
            });
            
            const baseSha = pr.base.sha;
            const headSha = pr.head.sha;
            
            // Return the values
            return { baseSha, headSha };

      - name: Generate diff
        id: diff
        run: |
          # Parse the JSON output from previous step
          PR_DATA='${{ steps.pr.outputs.result }}'
          BASE_SHA=$(echo $PR_DATA | jq -r '.baseSha')
          HEAD_SHA=$(echo $PR_DATA | jq -r '.headSha')
          
          # Make sure we have both branches
          git fetch origin $BASE_SHA --depth=1
          git fetch origin $HEAD_SHA --depth=1
          
          # Generate diff
          git diff $BASE_SHA $HEAD_SHA > pr_diff.txt
          
          # Check if diff file exists and has content
          if [ -s pr_diff.txt ]; then
            echo "DIFF_SIZE=$(stat -c%s pr_diff.txt)" >> $GITHUB_OUTPUT
          else
            echo "DIFF_SIZE=0" >> $GITHUB_OUTPUT
            echo "No meaningful diff found between commits." >> $GITHUB_STEP_SUMMARY
          fi

      - name: Setup Node.js v22
        uses: actions/setup-node@v4
        with:
          node-version: '22'
          
      - name: Install AMP CLI
        run: npm install -g @sourcegraph/amp

      - name: Run AMP review
        id: amp_review
        if: steps.diff.outputs.DIFF_SIZE != '0'
        env:
          AMP_API_KEY: ${{ secrets.AMP_API_KEY }}
        run: |
          # Create prompt file with diff
          {
            echo "Please review this PR, look at the diff and suggest improvements, please also include the severity of your review. If you have a reccomended prompt to fix these issues please also include it in your comment. Check to see if there are enough unit tests for any new features that have been added. Do not use TODOS"
          
          } > amp_input.txt
          
          # Run AMP with the combined input
          cat amp_input.txt | amp --no-color --no-notifications > amp_full_output.txt
          
          # Extract only the review content after any CLI output
          # Look for common patterns that indicate the start of the actual review
          if grep -q "AMP Code Review\|PR Review\|Code Review\|Review:" amp_full_output.txt; then
            # Find the line where the actual review starts and extract from there
            awk '/AMP Code Review|PR Review|Code Review|Review:/{found=1} found' amp_full_output.txt > amp_review.txt
          elif grep -q "Severity:\|Critical Issues\|Issues:\|Analysis:" amp_full_output.txt; then
            # Alternative patterns for review content
            awk '/Severity:|Critical Issues|Issues:|Analysis:/{found=1} found' amp_full_output.txt > amp_review.txt
          else
            # If no specific pattern found, try to remove common CLI prefixes
            sed '/^â•­\|^â”‚\|^â•°\|^Update TODOs\|^TODOs:/d' amp_full_output.txt | sed '/^$/N;/^\n$/d' > amp_review.txt
          fi
          
          # If the filtered file is empty or very small, fall back to the full output
          if [ ! -s amp_review.txt ] || [ $(wc -c < amp_review.txt) -lt 50 ]; then
            cp amp_full_output.txt amp_review.txt
          fi

      - name: Create individual PR comments from review
        if: steps.diff.outputs.DIFF_SIZE != '0'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.AMP_REVIEW_GH_TOKEN }}
          script: |
            const fs = require('fs');
            let reviewContent;
            
            try {
              reviewContent = fs.readFileSync('amp_review.txt', 'utf8');
            } catch (error) {
              console.error('Error reading amp_review.txt:', error);
              reviewContent = 'Error generating review.';
            }
            
            // Parse review content to extract individual issues
            function parseReviewIssues(content) {
              const issues = [];
              const lines = content.split('\n');
              let currentIssue = null;
              let severity = 'MEDIUM';
              
              // Extract overall severity from the content
              const severityMatch = content.match(/\*\*Severity:\s*(\w+)\*\*/i);
              if (severityMatch) {
                severity = severityMatch[1].toUpperCase();
              }
              
              for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                
                // Look for numbered issues in the format: "1. **Title** - Description"
                const issueMatch = line.match(/^\d+\.\s+\*\*(.+?)\*\*\s*-\s*(.+)/);
                if (issueMatch) {
                  if (currentIssue) {
                    issues.push(currentIssue);
                  }
                  
                  currentIssue = {
                    title: issueMatch[1],
                    description: issueMatch[2],
                    body: '',
                    severity: severity,
                    priority: severity === 'HIGH' || severity === 'CRITICAL' ? 'ðŸ”´ HIGH' : 
                             severity === 'MEDIUM' ? 'ðŸŸ¡ MEDIUM' : 'ðŸŸ¢ LOW'
                  };
                  
                } else if (currentIssue && line.length > 0 && !line.startsWith('#') && !line.startsWith('**')) {
                  // Add additional context to current issue
                  currentIssue.body += line + '\n';
                }
              }
              
              if (currentIssue) {
                issues.push(currentIssue);
              }
              
              return issues;
            }
            
            const issues = parseReviewIssues(reviewContent);
            
            // First, remove existing bot comments to avoid clutter
            try {
              const { data: existingComments } = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
              });
              
              const botComments = existingComments.filter(comment => 
                comment.body.includes('ðŸ¤– **Code Review Issue**') || 
                comment.body.includes('ðŸ¤– AMP Code Review Summary')
              );
              
              for (const comment of botComments) {
                await github.rest.issues.deleteComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_id: comment.id
                });
                console.log('Deleted existing bot comment #' + comment.id);
              }
            } catch (error) {
              console.log('Note: Could not clean up existing comments:', error.message);
            }
            
            const createdComments = [];
            
            // Create individual PR comments for each parsed issue
            for (let i = 0; i < issues.length; i++) {
              const issue = issues[i];
              try {
                const commentBody = '## ðŸ¤– **Code Review Issue #' + (i + 1) + '**\n\n' +
                  '### ' + issue.priority + ' - ' + issue.title + '\n\n' +
                  issue.description + '\n\n' +
                  (issue.body ? '**Additional Details:**\n' + issue.body + '\n' : '') +
                  '---\n*Generated by AMP Code Review Bot for PR #' + context.issue.number + '*';
                
                const { data: createdComment } = await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.issue.number,
                  body: commentBody
                });
                
                createdComments.push({
                  id: createdComment.id,
                  title: issue.title,
                  priority: issue.priority
                });
                
                console.log('Created comment for: ' + issue.title);
              } catch (error) {
                console.error('Error creating comment for ' + issue.title + ':', error);
              }
            }
            
            // Create summary comment on PR
            let summaryBody = '## ðŸ¤– AMP Code Review Summary\n\n';
            
            if (createdComments.length > 0) {
              summaryBody += 'Found **' + createdComments.length + '** issues that need attention. See individual comments above for details.\n\n';
              
              summaryBody += '**Issues Summary:**\n';
              createdComments.forEach((comment, index) => {
                summaryBody += (index + 1) + '. ' + comment.priority + ' - ' + comment.title + '\n';
              });
              
              summaryBody += '\n**Next Steps:**\n';
              summaryBody += '- Address each issue listed in the comments above\n';
              summaryBody += '- Reply to individual comments when issues are resolved\n';
              summaryBody += '- Re-request review when all issues are addressed\n\n';
            } else {
              summaryBody += 'No specific issues found to comment on. âœ…\n\n';
              summaryBody += '**Full Review:**\n\n```\n' + reviewContent + '\n```';
            }
            
            summaryBody += '\n---\n*Review completed on ' + new Date().toISOString().split('T')[0] + '*';
            
            try {
              const { data: summaryComment } = await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: summaryBody
              });
              console.log('Created summary comment');
            } catch (error) {
              console.error('Error posting summary comment:', error);
            }