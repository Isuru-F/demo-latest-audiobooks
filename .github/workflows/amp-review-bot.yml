name: AMP Review Bot

on:
  pull_request:
    types: [opened, synchronize]

permissions:
  contents: read
  pull-requests: write

jobs:
  amp-review:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Fetch PR data
        id: pr
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.AMP_REVIEW_GH_TOKEN }}
          script: |
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number
            });
            
            const baseSha = pr.base.sha;
            const headSha = pr.head.sha;
            
            // Return the values
            return { baseSha, headSha };

      - name: Generate diff
        id: diff
        run: |
          # Parse the JSON output from previous step
          PR_DATA='${{ steps.pr.outputs.result }}'
          BASE_SHA=$(echo $PR_DATA | jq -r '.baseSha')
          HEAD_SHA=$(echo $PR_DATA | jq -r '.headSha')
          
          # Make sure we have both branches
          git fetch origin $BASE_SHA --depth=1
          git fetch origin $HEAD_SHA --depth=1
          
          # Generate diff
          git diff $BASE_SHA $HEAD_SHA > pr_diff.txt
          
          # Check if diff file exists and has content
          if [ -s pr_diff.txt ]; then
            echo "DIFF_SIZE=$(stat -c%s pr_diff.txt)" >> $GITHUB_OUTPUT
          else
            echo "DIFF_SIZE=0" >> $GITHUB_OUTPUT
            echo "No meaningful diff found between commits." >> $GITHUB_STEP_SUMMARY
          fi

      - name: Setup Node.js v22
        uses: actions/setup-node@v4
        with:
          node-version: '22'
          
      - name: Install AMP CLI
        run: npm install -g @sourcegraph/amp

      - name: Run AMP review
        id: amp_review
        if: steps.diff.outputs.DIFF_SIZE != '0'
        env:
          AMP_API_KEY: ${{ secrets.AMP_API_KEY }}
        run: |
          # Create prompt file with diff
          {
            echo "Please review this PR and provide feedback in the following EXACT format:"
            echo ""
            echo "REQUIRED FORMAT:"
            echo "**Severity: [HIGH|MEDIUM|LOW]**"
            echo ""
            echo "### Issues Found:"
            echo ""
            echo "1. **ðŸ”´ HIGH - [Issue Title]**"
            echo "   - [Description of the issue]"
            echo "   - [Additional context if needed]"
            echo ""
            echo "2. **ðŸŸ¡ MEDIUM - [Issue Title]**"
            echo "   - [Description of the issue]"
            echo ""
            echo "3. **ðŸŸ¢ LOW - [Issue Title]**"
            echo "   - [Description of the issue]"
            echo ""
            echo "IMPORTANT: Each issue MUST be numbered and start with priority emoji (ðŸ”´/ðŸŸ¡/ðŸŸ¢) and priority level (HIGH/MEDIUM/LOW)."
            echo ""
            echo "Please analyze the following diff for:"
            echo "- Missing or insufficient unit tests"
            echo "- Security vulnerabilities"
            echo "- Performance issues"
            echo "- Code quality problems"
            echo "- Architecture concerns"
            echo "- Best practices violations"
            echo ""
            echo "DIFF:"
            cat pr_diff.txt
          } > amp_input.txt
          
          # Run AMP with the combined input
          cat amp_input.txt | amp --no-color --no-notifications > amp_full_output.txt
          
          # Extract only the review content after any CLI output
          # Look for common patterns that indicate the start of the actual review
          if grep -q "AMP Code Review\|PR Review\|Code Review\|Review:" amp_full_output.txt; then
            # Find the line where the actual review starts and extract from there
            awk '/AMP Code Review|PR Review|Code Review|Review:/{found=1} found' amp_full_output.txt > amp_review.txt
          elif grep -q "Severity:\|Critical Issues\|Issues:\|Analysis:" amp_full_output.txt; then
            # Alternative patterns for review content
            awk '/Severity:|Critical Issues|Issues:|Analysis:/{found=1} found' amp_full_output.txt > amp_review.txt
          else
            # If no specific pattern found, try to remove common CLI prefixes
            sed '/^â•­\|^â”‚\|^â•°\|^Update TODOs\|^TODOs:/d' amp_full_output.txt | sed '/^$/N;/^\n$/d' > amp_review.txt
          fi
          
          # If the filtered file is empty or very small, fall back to the full output
          if [ ! -s amp_review.txt ] || [ $(wc -c < amp_review.txt) -lt 50 ]; then
            cp amp_full_output.txt amp_review.txt
          fi

      - name: Create individual PR comments from review
        if: steps.diff.outputs.DIFF_SIZE != '0'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.AMP_REVIEW_GH_TOKEN }}
          script: |
            const fs = require('fs');
            let reviewContent;
            
            try {
              reviewContent = fs.readFileSync('amp_review.txt', 'utf8');
            } catch (error) {
              console.error('Error reading amp_review.txt:', error);
              reviewContent = 'Error generating review.';
            }
            
            // Parse review content to extract individual issues with multiple fallback patterns
            function parseReviewIssues(content) {
              const issues = [];
              const lines = content.split('\n');
              let currentIssue = null;
              let severity = 'MEDIUM';
              
              // Extract overall severity from the content (multiple patterns)
              const severityPatterns = [
                /\*\*Severity:\s*([\w-]+)\*\*/i,
                /Severity:\s*\*\*([\w-]+)\*\*/i,
                /\*\*Severity\*\*:\s*([\w-]+)/i
              ];
              
              for (const pattern of severityPatterns) {
                const match = content.match(pattern);
                if (match) {
                  severity = match[1].toUpperCase();
                  break;
                }
              }
              
              console.log('Parsing content for issues... Overall severity: ' + severity);
              
              // Multiple patterns to match numbered issues
              const issuePatterns = [
                // Pattern 1: "1. **ðŸ”´ HIGH - Title**"
                /^(\d+)\.\s+\*\*([ðŸ”´ðŸŸ¡ðŸŸ¢])?\s*(HIGH|MEDIUM|LOW)?\s*-?\s*(.+?)\*\*\s*$/,
                // Pattern 2: "1. **Title**"
                /^(\d+)\.\s+\*\*(.+?)\*\*\s*$/,
                // Pattern 3: "1. Title (no bold)"
                /^(\d+)\.\s+([ðŸ”´ðŸŸ¡ðŸŸ¢])?\s*(HIGH|MEDIUM|LOW)?\s*-?\s*(.+)$/,
                // Pattern 4: Bullet points "- **Title**"
                /^-\s+\*\*(.+?)\*\*\s*$/
              ];
              
              for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                let matched = false;
                
                // Try each pattern
                for (let patternIndex = 0; patternIndex < issuePatterns.length; patternIndex++) {
                  const pattern = issuePatterns[patternIndex];
                  const match = line.match(pattern);
                  
                  if (match) {
                    // Finish previous issue
                    if (currentIssue) {
                      issues.push(currentIssue);
                    }
                    
                    let issueNumber, emoji, priorityText, title;
                    
                    if (patternIndex === 0) {
                      // Pattern 1: Full format with emoji and priority
                      issueNumber = match[1];
                      emoji = match[2] || 'ðŸŸ¡';
                      priorityText = match[3] || 'MEDIUM';
                      title = match[4];
                    } else if (patternIndex === 1) {
                      // Pattern 2: Just number and title
                      issueNumber = match[1];
                      title = match[2];
                      // Extract emoji and priority from title if present
                      const titleMatch = title.match(/^([ðŸ”´ðŸŸ¡ðŸŸ¢])?\s*(HIGH|MEDIUM|LOW)?\s*-?\s*(.+)$/);
                      if (titleMatch) {
                        emoji = titleMatch[1] || 'ðŸŸ¡';
                        priorityText = titleMatch[2] || 'MEDIUM';
                        title = titleMatch[3];
                      } else {
                        emoji = 'ðŸŸ¡';
                        priorityText = 'MEDIUM';
                      }
                    } else if (patternIndex === 2) {
                      // Pattern 3: Simple numbered list
                      issueNumber = match[1];
                      emoji = match[2] || 'ðŸŸ¡';
                      priorityText = match[3] || 'MEDIUM';
                      title = match[4];
                    } else {
                      // Pattern 4: Bullet point
                      issueNumber = (issues.length + 1).toString();
                      title = match[1];
                      emoji = 'ðŸŸ¡';
                      priorityText = 'MEDIUM';
                    }
                    
                    // Determine priority display
                    let priority;
                    if (priorityText === 'HIGH' || emoji === 'ðŸ”´') {
                      priority = 'ðŸ”´ HIGH';
                    } else if (priorityText === 'LOW' || emoji === 'ðŸŸ¢') {
                      priority = 'ðŸŸ¢ LOW';
                    } else {
                      priority = 'ðŸŸ¡ MEDIUM';
                    }
                    
                    currentIssue = {
                      title: title.trim(),
                      description: '',
                      body: '',
                      severity: severity,
                      priority: priority,
                      number: issueNumber
                    };
                    
                    console.log('Found issue #' + issueNumber + ' (' + priority + '): ' + title.trim());
                    matched = true;
                    break;
                  }
                }
                
                // If not an issue header, check if it's content for current issue
                if (!matched && currentIssue) {
                  if (line.startsWith('- ')) {
                    // This is a description line
                    if (!currentIssue.description) {
                      currentIssue.description = line.substring(2).trim();
                    } else {
                      currentIssue.body += line + '\n';
                    }
                  } else if (line.length > 0 && !line.startsWith('#') && !line.startsWith('**') && !line.startsWith('```') && !line.startsWith('---')) {
                    // Add additional context to current issue
                    currentIssue.body += line + '\n';
                  }
                }
              }
              
              if (currentIssue) {
                issues.push(currentIssue);
              }
              
              console.log('Parsed ' + issues.length + ' issues total');
              
              // If no issues found, try to create at least one from the content
              if (issues.length === 0) {
                console.log('No structured issues found, creating generic issue from content');
                const fallbackIssue = {
                  title: 'Code Review Feedback',
                  description: 'Please review the detailed feedback below',
                  body: content.substring(0, 500) + (content.length > 500 ? '...' : ''),
                  severity: severity,
                  priority: 'ðŸŸ¡ MEDIUM',
                  number: '1'
                };
                issues.push(fallbackIssue);
              }
              
              return issues;
            }
            
            const issues = parseReviewIssues(reviewContent);
            
            // First, remove existing bot comments to avoid clutter
            try {
              const { data: existingComments } = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
              });
              
              const botComments = existingComments.filter(comment => 
                comment.body.includes('ðŸ¤– **Code Review Issue**') || 
                comment.body.includes('ðŸ¤– AMP Code Review Summary')
              );
              
              for (const comment of botComments) {
                await github.rest.issues.deleteComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_id: comment.id
                });
                console.log('Deleted existing bot comment #' + comment.id);
              }
            } catch (error) {
              console.log('Note: Could not clean up existing comments:', error.message);
            }
            
            const createdComments = [];
            
            // Create individual PR comments for each parsed issue
            for (let i = 0; i < issues.length; i++) {
              const issue = issues[i];
              try {
                const commentBody = '## ðŸ¤– **Code Review Issue #' + (i + 1) + '**\n\n' +
                  '### ' + issue.priority + ' - ' + issue.title + '\n\n' +
                  issue.description + '\n\n' +
                  (issue.body ? '**Additional Details:**\n' + issue.body + '\n' : '') +
                  '---\n*Generated by AMP Code Review Bot for PR #' + context.issue.number + '*';
                
                const { data: createdComment } = await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.issue.number,
                  body: commentBody
                });
                
                createdComments.push({
                  id: createdComment.id,
                  title: issue.title,
                  priority: issue.priority
                });
                
                console.log('Created comment for: ' + issue.title);
              } catch (error) {
                console.error('Error creating comment for ' + issue.title + ':', error);
              }
            }
            
            // Create summary comment on PR
            let summaryBody = '## ðŸ¤– AMP Code Review Summary\n\n';
            
            if (createdComments.length > 0) {
              summaryBody += 'Found **' + createdComments.length + '** issues that need attention. See individual comments above for details.\n\n';
              
              summaryBody += '**Issues Summary:**\n';
              createdComments.forEach((comment, index) => {
                summaryBody += (index + 1) + '. ' + comment.priority + ' - ' + comment.title + '\n';
              });
              
              summaryBody += '\n**Next Steps:**\n';
              summaryBody += '- Address each issue listed in the comments above\n';
              summaryBody += '- Reply to individual comments when issues are resolved\n';
              summaryBody += '- Re-request review when all issues are addressed\n\n';
            } else {
              summaryBody += 'No specific issues found to comment on. âœ…\n\n';
              summaryBody += '**Full Review:**\n\n```\n' + reviewContent + '\n```';
            }
            
            summaryBody += '\n---\n*Review completed on ' + new Date().toISOString().split('T')[0] + '*';
            
            try {
              const { data: summaryComment } = await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: summaryBody
              });
              console.log('Created summary comment');
            } catch (error) {
              console.error('Error posting summary comment:', error);
            }