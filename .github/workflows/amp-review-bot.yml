name: Minimal Amp PR Bot

on:
  pull_request:
    types: [opened, synchronize]

permissions:
  contents: read
  pull-requests: write

env:
  AMP_TOOLBOX: ${{ github.workspace }}/.tools

jobs:
  amp-review:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Generate diff
        id: diff
        run: |
          git fetch origin ${{ github.event.pull_request.base.sha }} --depth=1
          git fetch origin ${{ github.event.pull_request.head.sha }} --depth=1
          
          git diff ${{ github.event.pull_request.base.sha }} ${{ github.event.pull_request.head.sha }} > pr_diff.txt
          
          if [ -s pr_diff.txt ]; then
            echo "HAS_DIFF=true" >> $GITHUB_OUTPUT
          else
            echo "HAS_DIFF=false" >> $GITHUB_OUTPUT
          fi

      - name: Setup Node.js
        if: steps.diff.outputs.HAS_DIFF == 'true'
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install Amp CLI
        if: steps.diff.outputs.HAS_DIFF == 'true'
        run: npm install -g @sourcegraph/amp@latest

      - name: Extract entities and review with Amp
        if: steps.diff.outputs.HAS_DIFF == 'true'
        env:
          AMP_API_KEY: ${{ secrets.AMP_API_KEY }}
        run: |
          # Extract entities using toolbox
          echo "Extracting entities..."
          ENTITIES_JSON=$(echo "diff_content: $(cat pr_diff.txt)" | TOOLBOX_ACTION=execute ./.tools/extract-diff-entities)
          echo "$ENTITIES_JSON" > entities.json
          
          ENTITY_COUNT=$(echo "$ENTITIES_JSON" | jq '.entities_found')
          echo "Found $ENTITY_COUNT entities to review"
          
          if [ "$ENTITY_COUNT" -eq 0 ]; then
            echo '{"tool":"amp","version":"0.2","issues":[]}' > amp_review.json
            exit 0
          fi
          
          # Create Amp thread
          echo "Creating thread for review..."
          THREAD_ID=$(amp threads new --visibility private)
          echo "Thread created: $THREAD_ID"
          
          # Review first entity
          FIRST_ENTITY=$(echo "$ENTITIES_JSON" | jq '.entities[0]')
          ENTITY_NAME=$(echo "$FIRST_ENTITY" | jq -r '.name')
          ENTITY_FILE=$(echo "$FIRST_ENTITY" | jq -r '.file')
          ENTITY_LINE=$(echo "$FIRST_ENTITY" | jq -r '.line')
          ENTITY_KIND=$(echo "$FIRST_ENTITY" | jq -r '.kind')
          
          cat << EOF | amp -x --stream-json threads continue $THREAD_ID > review_responses.jsonl
          Code Review Request: Please analyze this $ENTITY_KIND "$ENTITY_NAME" from $ENTITY_FILE at line $ENTITY_LINE.
          
          Focus on security, performance, and code quality issues. Provide structured analysis with:
          - Issue severity (HIGH/MEDIUM/LOW)
          - Specific problem description
          - Actionable recommendation
          
          Use the code_reviewer tool if available.
          EOF
          
          # Continue with remaining entities if any
          if [ "$ENTITY_COUNT" -gt 1 ]; then
            for i in $(seq 1 $((ENTITY_COUNT - 1))); do
              ENTITY=$(echo "$ENTITIES_JSON" | jq ".entities[$i]")
              ENTITY_NAME=$(echo "$ENTITY" | jq -r '.name')
              ENTITY_FILE=$(echo "$ENTITY" | jq -r '.file')
              ENTITY_LINE=$(echo "$ENTITY" | jq -r '.line')
              ENTITY_KIND=$(echo "$ENTITY" | jq -r '.kind')
              
              cat << EOF | amp -x --stream-json threads continue $THREAD_ID >> review_responses.jsonl
          Continue review: Analyze $ENTITY_KIND "$ENTITY_NAME" from $ENTITY_FILE at line $ENTITY_LINE.
          
          Same criteria: security, performance, code quality. Provide structured feedback.
          Use code_reviewer tool if available.
          EOF
            done
          fi
          
          # Process responses into GitHub format
          node -e '
            const fs = require("fs");
            const content = fs.readFileSync("review_responses.jsonl", "utf8");
            const lines = content.split("\n").filter(l => l.trim());
            
            let allText = "";
            for (const line of lines) {
              try {
                const parsed = JSON.parse(line);
                if (parsed.message?.content) {
                  for (const item of parsed.message.content) {
                    if (item.type === "text") allText += item.text + "\n";
                  }
                }
              } catch (e) {}
            }
            
            const issues = [];
            let id = 1;
            
            // Split analysis by individual entity reviews
            const entityReviews = allText.split(/Continue review:|Code Review Request:/).slice(1);
            
            for (const review of entityReviews) {
              if (!review.trim()) continue;
              
              // Extract entity info from the review prompt
              const entityFileMatch = review.match(/from ([^\\s]+\\.(?:vue|ts|js|yml))/);
              const entityLineMatch = review.match(/at line (\\d+)/);
              
              if (!entityFileMatch) continue;
              
              const entityFile = entityFileMatch[1];
              const entityLine = entityLineMatch ? parseInt(entityLineMatch[1], 10) : 1;
              
              // Extract only HIGH severity issues to avoid overwhelming the PR
              const highIssues = review.matchAll(/### \\*\\*HIGH\\*\\*: ([^\\n]+)(.*?)(?=###|\\*\\*Overall Assessment\\*\\*|$)/gs);
              
              for (const match of highIssues) {
                const title = match[1].replace(/^[^-]+-\\s*/, "").trim();
                const content = match[2];
                
                let suggestion = "See analysis for details";
                const recommendationMatch = content.match(/\\*\\*Recommendation\\*\\*:(.*?)(?=\\*\\*|```|$)/s);
                if (recommendationMatch) {
                  suggestion = recommendationMatch[1].trim().slice(0, 200);
                }
                
                issues.push({
                  id: id++,
                  severity: "HIGH",
                  title: title.slice(0, 80),
                  file: entityFile,
                  line: entityLine,
                  description: title.slice(0, 200),
                  suggestion: suggestion.replace(/\\n|\\t/g, " ").trim()
                });
              }
              
              // Also extract some critical MEDIUM issues for actual Vue code files (not workflow files)
              if (entityFile.includes("client/src/")) {
                const mediumIssues = review.matchAll(/### \\*\\*MEDIUM\\*\\*: ([^\\n]+)(.*?)(?=###|\\*\\*Overall Assessment\\*\\*|$)/gs);
                let mediumCount = 0;
                
                for (const match of mediumIssues) {
                  if (mediumCount >= 2) break; // Limit to 2 medium issues per entity
                  
                  const title = match[1].replace(/^[^-]+-\\s*/, "").trim();
                  const content = match[2];
                  
                  let suggestion = "See analysis for details";
                  const recommendationMatch = content.match(/\\*\\*Recommendation\\*\\*:(.*?)(?=\\*\\*|```|$)/s);
                  if (recommendationMatch) {
                    suggestion = recommendationMatch[1].trim().slice(0, 200);
                  }
                  
                  issues.push({
                    id: id++,
                    severity: "MEDIUM",
                    title: title.slice(0, 80),
                    file: entityFile,
                    line: entityLine,
                    description: title.slice(0, 200),
                    suggestion: suggestion.replace(/\\n|\\t/g, " ").trim()
                  });
                  
                  mediumCount++;
                }
              }
            }
            
            console.log(JSON.stringify({
              tool: "amp", version: "0.2",
              summary: issues.length ? `Found ${issues.length} issues using Amp toolbox analysis.` : "No issues found.",
              issues
            }, null, 2));
          ' > amp_review.json

      - name: Create GitHub review comments
        if: steps.diff.outputs.HAS_DIFF == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.AMP_REVIEW_GH_TOKEN }}
          script: |
            const fs = require('fs');

            function parseDiffFiles(diffContent) {
              const files = {};
              const lines = diffContent.split('\n');
              let currentFile = null;
              let oldLineNum = 0;
              let newLineNum = 0;
              let diffPosition = -1;

              for (let i = 0; i < lines.length; i++) {
                const line = lines[i];

                const fileMatch = line.match(/^diff --git a\/(.+) b\/(.+)$/);
                if (fileMatch) {
                  currentFile = fileMatch[2];
                  files[currentFile] = { lineMap: {}, diffHunks: [] };
                  diffPosition = -1;
                  continue;
                }

                if (line.startsWith('index ') || line.startsWith('new file') || 
                    line.startsWith('deleted file') || line.startsWith('--- ') || line.startsWith('+++ ')) {
                  continue;
                }

                const hunkMatch = line.match(/^@@ -(\d+),?\d* \+(\d+),?\d* @@/);
                if (hunkMatch && currentFile) {
                  oldLineNum = parseInt(hunkMatch[1]);
                  newLineNum = parseInt(hunkMatch[2]);
                  diffPosition++;
                  files[currentFile].diffHunks.push({ oldStart: oldLineNum, newStart: newLineNum, position: diffPosition });
                  continue;
                }

                if (currentFile && (line.startsWith('+') || line.startsWith('-') || line.startsWith(' '))) {
                  diffPosition++;
                  if (line.startsWith('+') && !line.startsWith('+++')) {
                    files[currentFile].lineMap[newLineNum] = { type: 'added', line: newLineNum, position: diffPosition, side: 'RIGHT' };
                    newLineNum++;
                  } else if (line.startsWith('-') && !line.startsWith('---')) {
                    oldLineNum++;
                  } else if (line.startsWith(' ')) {
                    files[currentFile].lineMap[newLineNum] = { type: 'context', line: newLineNum, position: diffPosition, side: 'RIGHT' };
                    oldLineNum++;
                    newLineNum++;
                  }
                }
              }

              return files;
            }

            let ampJson;
            try {
              const raw = fs.readFileSync('amp_review.json', 'utf8');
              ampJson = JSON.parse(raw);
            } catch (e) {
              console.log('Could not read amp_review.json:', e.message);
              return;
            }

            if (!ampJson.issues || !Array.isArray(ampJson.issues)) {
              console.log('No issues found in amp_review.json');
              return;
            }

            const diffContent = fs.readFileSync('pr_diff.txt', 'utf8');
            const diffFiles = parseDiffFiles(diffContent);
            
            const reviewComments = [];
            
            for (const issue of ampJson.issues) {
              const file = issue.file?.trim();
              const line = Number(issue.line);
              
              if (!file || !Number.isFinite(line) || !diffFiles[file]) continue;
              
              const fileData = diffFiles[file];
              let diffPosition = fileData.lineMap[line]?.position;
              
              if (!diffPosition && fileData.diffHunks.length > 0) {
                diffPosition = fileData.diffHunks[0].position + 1;
              }
              
              if (diffPosition) {
                const sevToTag = (sev) => {
                  if (sev === 'HIGH') return '🔴 HIGH';
                  if (sev === 'LOW') return '🟢 LOW';
                  return '🟡 MEDIUM';
                };

                const priority = sevToTag(issue.severity);
                const suggestion = issue.suggestion ? `**Suggestion:** ${issue.suggestion}\n\n` : '';
                const body = `**${priority} - ${issue.title}**\n\n${issue.description}\n\n${suggestion}---\n* Generated by Amp Toolbox Review`;

                reviewComments.push({ path: file, position: diffPosition, body });
              }
            }

            if (reviewComments.length > 0) {
              await github.rest.pulls.createReview({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: context.issue.number,
                body: `## 🧰 Amp Toolbox Review\n\nFound **${reviewComments.length}** issues using toolbox analysis with thread reuse.\n\n---\n*Review completed on ${new Date().toISOString().split('T')[0]}*`,
                event: 'REQUEST_CHANGES',
                comments: reviewComments,
              });
            } else {
              await github.rest.pulls.createReview({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: context.issue.number,
                body: `## 🧰 Amp Toolbox Review\n\nNo issues found. ✅\n\n---\n*Review completed on ${new Date().toISOString().split('T')[0]}*`,
                event: 'COMMENT',
              });
            }

      - name: Upload artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: amp-review-artifacts
          path: |
            pr_diff.txt
            entities.json
            review_responses.jsonl
            amp_review.json
          retention-days: 3
