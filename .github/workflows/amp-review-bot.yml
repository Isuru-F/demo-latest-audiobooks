name: AMP Review Bot

on:
  pull_request:
    types: [opened, synchronize]

permissions:
  contents: read
  pull-requests: write

jobs:
  amp-review:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Fetch PR data
        id: pr
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.AMP_REVIEW_GH_TOKEN }}
          script: |
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number
            });
            
            const baseSha = pr.base.sha;
            const headSha = pr.head.sha;
            
            // Return the values
            return { baseSha, headSha };

      - name: Generate diff
        id: diff
        run: |
          # Parse the JSON output from previous step
          PR_DATA='${{ steps.pr.outputs.result }}'
          BASE_SHA=$(echo $PR_DATA | jq -r '.baseSha')
          HEAD_SHA=$(echo $PR_DATA | jq -r '.headSha')
          
          # Make sure we have both branches
          git fetch origin $BASE_SHA --depth=1
          git fetch origin $HEAD_SHA --depth=1
          
          # Generate diff
          git diff $BASE_SHA $HEAD_SHA > pr_diff.txt
          
          # Check if diff file exists and has content
          if [ -s pr_diff.txt ]; then
            echo "DIFF_SIZE=$(stat -c%s pr_diff.txt)" >> $GITHUB_OUTPUT
          else
            echo "DIFF_SIZE=0" >> $GITHUB_OUTPUT
            echo "No meaningful diff found between commits." >> $GITHUB_STEP_SUMMARY
          fi

      - name: Setup Node.js v22
        uses: actions/setup-node@v4
        with:
          node-version: '22'
          
      - name: Install AMP CLI
        run: npm install -g @sourcegraph/amp

      - name: Run AMP review
        id: amp_review
        if: steps.diff.outputs.DIFF_SIZE != '0'
        env:
          AMP_API_KEY: ${{ secrets.AMP_API_KEY }}
        run: |
          # Create prompt file with diff
          {
            echo "Please review this PR, look at the diff and suggest improvements, please also include the severity of your review. If you have a reccomended prompt to fix these issues please also include it in your comment. Check to see if there are enough unit tests for any new features that have been added. Do not use TODOS"
          
          } > amp_input.txt
          
          # Run AMP with the combined input
          cat amp_input.txt | amp --no-color --no-notifications > amp_full_output.txt
          
          # Extract only the review content after any CLI output
          # Look for common patterns that indicate the start of the actual review
          if grep -q "AMP Code Review\|PR Review\|Code Review\|Review:" amp_full_output.txt; then
            # Find the line where the actual review starts and extract from there
            awk '/AMP Code Review|PR Review|Code Review|Review:/{found=1} found' amp_full_output.txt > amp_review.txt
          elif grep -q "Severity:\|Critical Issues\|Issues:\|Analysis:" amp_full_output.txt; then
            # Alternative patterns for review content
            awk '/Severity:|Critical Issues|Issues:|Analysis:/{found=1} found' amp_full_output.txt > amp_review.txt
          else
            # If no specific pattern found, try to remove common CLI prefixes
            sed '/^â•­\|^â”‚\|^â•°\|^Update TODOs\|^TODOs:/d' amp_full_output.txt | sed '/^$/N;/^\n$/d' > amp_review.txt
          fi
          
          # If the filtered file is empty or very small, fall back to the full output
          if [ ! -s amp_review.txt ] || [ $(wc -c < amp_review.txt) -lt 50 ]; then
            cp amp_full_output.txt amp_review.txt
          fi

      - name: Create GitHub issues from review
        if: steps.diff.outputs.DIFF_SIZE != '0'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.AMP_REVIEW_GH_TOKEN }}
          script: |
            const fs = require('fs');
            let reviewContent;
            
            try {
              reviewContent = fs.readFileSync('amp_review.txt', 'utf8');
            } catch (error) {
              console.error('Error reading amp_review.txt:', error);
              reviewContent = 'Error generating review.';
            }
            
            // Parse review content to extract individual issues
            function parseReviewIssues(content) {
              const issues = [];
              const lines = content.split('\n');
              let currentIssue = null;
              let severity = 'MEDIUM';
              
              // Extract severity from the content
              const severityMatch = content.match(/\*\*Severity:\s*(\w+)\*\*/i);
              if (severityMatch) {
                severity = severityMatch[1].toUpperCase();
              }
              
              for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                
                // Look for numbered issues
                const issueMatch = line.match(/^\d+\.\s+\*\*(.+?)\*\*\s*-\s*(.+)/);
                if (issueMatch) {
                  if (currentIssue) {
                    issues.push(currentIssue);
                  }
                  
                  currentIssue = {
                    title: issueMatch[1],
                    description: issueMatch[2],
                    body: '',
                    severity: severity,
                    labels: []
                  };
                  
                  // Add labels based on content and severity
                  if (line.toLowerCase().includes('test')) {
                    currentIssue.labels.push('testing');
                  }
                  if (line.toLowerCase().includes('security')) {
                    currentIssue.labels.push('security');
                  }
                  if (line.toLowerCase().includes('performance')) {
                    currentIssue.labels.push('performance');
                  }
                  
                  // Add severity label
                  if (severity === 'HIGH' || severity === 'CRITICAL') {
                    currentIssue.labels.push('high priority');
                  } else if (severity === 'MEDIUM') {
                    currentIssue.labels.push('medium priority');
                  } else {
                    currentIssue.labels.push('low priority');
                  }
                  
                  currentIssue.labels.push('code review');
                  
                } else if (currentIssue && line.length > 0 && !line.startsWith('#')) {
                  // Add additional context to current issue
                  currentIssue.body += line + '\n';
                }
              }
              
              if (currentIssue) {
                issues.push(currentIssue);
              }
              
              return issues;
            }
            
            const issues = parseReviewIssues(reviewContent);
            const createdIssues = [];
            
            // Create GitHub issues for each parsed issue
            for (const issue of issues) {
              try {
                const issueBody = '**Generated from PR #' + context.issue.number + ' Code Review**\n\n' + 
                  issue.description + '\n\n' + 
                  issue.body + '\n\n' +
                  '**Severity:** ' + issue.severity + '\n\n' +
                  '**Related PR:** #' + context.issue.number + '\n\n' +
                  '---\n*This issue was automatically created by AMP Code Review Bot*';
                
                const { data: createdIssue } = await github.rest.issues.create({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  title: '[Code Review] ' + issue.title,
                  body: issueBody,
                  labels: issue.labels
                });
                
                createdIssues.push({
                  number: createdIssue.number,
                  title: issue.title,
                  url: createdIssue.html_url
                });
                
                console.log('Created issue #' + createdIssue.number + ': ' + issue.title);
              } catch (error) {
                console.error('Error creating issue for ' + issue.title + ':', error);
              }
            }
            
            // Create summary comment on PR
            let summaryBody = '## ðŸ¤– AMP Code Review Summary\n\n';
            
            if (createdIssues.length > 0) {
              summaryBody += 'Found **' + createdIssues.length + '** issues that need attention:\n\n';
              
              createdIssues.forEach((issue, index) => {
                summaryBody += (index + 1) + '. [' + issue.title + '](' + issue.url + ') - Issue #' + issue.number + '\n';
              });
              
              summaryBody += '\n**Next Steps:**\n';
              summaryBody += '- Review and address each issue linked above\n';
              summaryBody += '- Close issues as they are resolved\n';
              summaryBody += '- Re-request review when ready\n\n';
            } else {
              summaryBody += 'No specific issues found to create. âœ…\n\n';
              summaryBody += '**Full Review:**\n\n```\n' + reviewContent + '\n```';
            }
            
            summaryBody += '\n---\n*Issues created from PR review on ' + new Date().toISOString().split('T')[0] + '*';
            
            try {
              // Find existing summary comment to update
              const { data: comments } = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
              });
              
              const botComment = comments.find(comment => 
                comment.body.includes('ðŸ¤– AMP Code Review Summary')
              );
              
              if (botComment) {
                await github.rest.issues.updateComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_id: botComment.id,
                  body: summaryBody
                });
                console.log('Updated existing summary comment');
              } else {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.issue.number,
                  body: summaryBody
                });
                console.log('Created new summary comment');
              }
            } catch (error) {
              console.error('Error posting summary comment:', error);
            }